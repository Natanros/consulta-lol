// Servi√ßo para consulta de invocador usando proxy local
// Em produ√ß√£o (Vercel), usar o pr√≥prio dom√≠nio. Em desenvolvimento, localhost
const PROXY_URL =
  process.env.REACT_APP_PROXY_URL ||
  (process.env.NODE_ENV === "production"
    ? "" // Em produ√ß√£o, usar o mesmo dom√≠nio (rotas relativas)
    : "http://localhost:3001"); // Em desenvolvimento, usar proxy local

// Interface para dados do invocador
interface SummonerData {
  name: string;
  level: number;
  icon: number;
  puuid: string;
  summonerId: string;
  accountId: string;
}

// Fun√ß√£o para buscar dados com o proxy local
const fetchWithLocalProxy = async (endpoint: string) => {
  try {
    const response = await fetch(`${PROXY_URL}${endpoint}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
      // Timeout para evitar espera infinita
      signal: AbortSignal.timeout(5000), // 5 segundos
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error || `Erro HTTP: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error: any) {
    console.error("Erro ao comunicar com proxy local:", error);

    // Se for erro de conex√£o recusada, mensagem mais clara
    if (error.name === "TypeError" && error.message.includes("fetch")) {
      throw new Error("Proxy local n√£o est√° rodando. Execute: pnpm run proxy");
    }

    throw error;
  }
};

export const searchSummonerLocal = async (
  riotId: string
): Promise<SummonerData> => {
  // Validar formato do Riot ID
  const [gameName, tagLine] = riotId.split("#");

  if (!gameName || !tagLine) {
    throw new Error("Formato do Riot ID inv√°lido. Use o formato: Nome#Tag");
  }

  try {
    // Passo 1: Buscar dados da conta pelo Riot ID
    const accountData = await fetchWithLocalProxy(
      `/api/account/${encodeURIComponent(gameName)}/${encodeURIComponent(
        tagLine
      )}`
    );

    if (!accountData || !accountData.puuid) {
      throw new Error("Conta n√£o encontrada. Verifique o Riot ID.");
    }

    // Passo 2: Buscar dados do invocador pelo PUUID
    const summonerData = await fetchWithLocalProxy(
      `/api/summoner/by-puuid/${accountData.puuid}`
    );

    if (!summonerData || !summonerData.summonerLevel) {
      console.error("Dados inv√°lidos recebidos:", summonerData);
      throw new Error("Dados do invocador n√£o encontrados.");
    }

    // Retornar dados estruturados
    const result: SummonerData = {
      name: `${accountData.gameName}#${accountData.tagLine}`,
      level: summonerData.summonerLevel,
      icon: summonerData.profileIconId,
      puuid: accountData.puuid,
      summonerId: summonerData.id || summonerData.puuid,
      accountId:
        summonerData.accountId || summonerData.id || summonerData.puuid,
    };

    return result;
  } catch (error: any) {
    console.error("Erro na busca do invocador:", error);

    // Melhorar mensagens de erro para o usu√°rio
    const errorMessage = error.message || error.toString();
    const errorResponse = error.response;

    // Erro de resposta HTTP
    if (errorResponse) {
      const status = errorResponse.status;

      if (status === 404) {
        const customError: any = new Error("Invocador n√£o encontrado");
        customError.type = "NOT_FOUND";
        customError.suggestions = [
          "Verifique se o nome do invocador est√° correto",
          "Certifique-se de incluir a tag (ex: Nome#TAG)",
          "Confirme se o invocador est√° na regi√£o BR1",
        ];
        throw customError;
      } else if (status === 403) {
        const customError: any = new Error("Acesso negado pela API da Riot");
        customError.type = "FORBIDDEN";
        customError.suggestions = [
          "A chave da API pode estar inv√°lida ou expirada",
          "Chaves de desenvolvimento expiram em 24 horas",
          "Verifique se a API key est√° configurada corretamente",
        ];
        throw customError;
      } else if (status === 429) {
        const customError: any = new Error("Limite de requisi√ß√µes excedido");
        customError.type = "RATE_LIMIT";
        customError.suggestions = [
          "Aguarde alguns segundos antes de tentar novamente",
          "A API da Riot tem limite de 20 req/segundo",
          "Tente novamente em 1-2 minutos",
        ];
        throw customError;
      } else if (status >= 500) {
        const customError: any = new Error("Erro nos servidores da Riot Games");
        customError.type = "SERVER_ERROR";
        customError.suggestions = [
          "Os servidores da Riot est√£o com problemas",
          "Tente novamente em alguns minutos",
          "Verifique o status em: status.riotgames.com",
        ];
        throw customError;
      }
    }

    // Erro de conex√£o
    if (
      errorMessage.includes("Failed to fetch") ||
      errorMessage.includes("NetworkError") ||
      errorMessage.includes("Network Error") ||
      errorMessage.includes("ECONNREFUSED")
    ) {
      const customError: any = new Error(
        "N√£o foi poss√≠vel conectar ao servidor proxy"
      );
      customError.type = "CONNECTION_ERROR";
      customError.suggestions = [
        `Verifique se o servidor proxy est√° rodando em ${PROXY_URL}`,
        "Execute: npm run proxy",
        "Ou: npm run dev (para iniciar proxy + frontend)",
      ];
      throw customError;
    }

    // Erro gen√©rico
    const customError: any = new Error(
      errorMessage || "Erro desconhecido ao buscar invocador"
    );
    customError.type = "UNKNOWN";
    throw customError;
  }
};

// Fun√ß√£o para buscar rota√ß√£o semanal via proxy local
export const getWeeklyRotationLocal = async () => {
  try {
    const data = await fetchWithLocalProxy("/api/rotation");

    if (!data || !data.freeChampionIds) {
      throw new Error("Dados de rota√ß√£o inv√°lidos");
    }

    return data;
  } catch (error: any) {
    console.error("Erro ao buscar rota√ß√£o:", error);
    throw error;
  }
};

// Fun√ß√£o auxiliar para obter URL do √≠cone do invocador
export const getSummonerIconUrl = (iconId: number): string => {
  return `https://ddragon.leagueoflegends.com/cdn/14.1.1/img/profileicon/${iconId}.png`;
};

// Fun√ß√£o para validar Riot ID
export const isValidRiotId = (riotId: string): boolean => {
  const pattern = /^.+#.+$/;
  return (
    pattern.test(riotId) &&
    riotId.includes("#") &&
    riotId.split("#").length === 2
  );
};

// Fun√ß√£o para verificar se o proxy local est√° dispon√≠vel
export const checkProxyHealth = async (): Promise<boolean> => {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 segundos timeout

    const response = await fetch(`${PROXY_URL}/health`, {
      method: "GET",
      cache: "no-cache",
      signal: controller.signal,
    });

    clearTimeout(timeoutId);
    return response.ok;
  } catch (error: any) {
    if (error.name !== "AbortError") {
      console.error("Proxy local n√£o est√° dispon√≠vel:", error.message);
    }
    return false;
  }
};

// Buscar maestrias do jogador
export const getChampionMasteries = async (puuid: string) => {
  try {
    console.log(
      `üèÜ Buscando maestrias para PUUID: ${puuid.substring(0, 20)}...`
    );
    const masteries = await fetchWithLocalProxy(
      `/api/champion-mastery/${puuid}`
    );
    console.log(`‚úÖ ${masteries.length} maestrias encontradas`);
    return masteries;
  } catch (error: any) {
    console.error("‚ùå Erro ao buscar maestrias:", error);
    throw new Error("N√£o foi poss√≠vel buscar as maestrias do jogador.");
  }
};

// Buscar hist√≥rico de partidas
export const getMatchHistory = async (puuid: string, count: number = 10) => {
  try {
    console.log(
      `üìú Buscando hist√≥rico de partidas para PUUID: ${puuid.substring(
        0,
        20
      )}...`
    );
    const matchIds = await fetchWithLocalProxy(
      `/api/match-history/${puuid}?count=${count}`
    );
    console.log(`‚úÖ ${matchIds.length} partidas encontradas`);
    return matchIds;
  } catch (error: any) {
    console.error("‚ùå Erro ao buscar hist√≥rico:", error);
    throw new Error("N√£o foi poss√≠vel buscar o hist√≥rico de partidas.");
  }
};

// Buscar detalhes de uma partida
export const getMatchDetails = async (matchId: string) => {
  try {
    console.log(`üéÆ Buscando detalhes da partida: ${matchId}`);
    const matchData = await fetchWithLocalProxy(`/api/match/${matchId}`);
    console.log(`‚úÖ Detalhes da partida obtidos`);
    return matchData;
  } catch (error: any) {
    console.error("‚ùå Erro ao buscar detalhes da partida:", error);
    throw new Error("N√£o foi poss√≠vel buscar os detalhes da partida.");
  }
};
